@startuml System.CommandLine Command Flow
!theme aws-orange
title Command Execution Flow: Nuke.Build vs System.CommandLine

participant "CLI User" as user
participant "Program" as prog1 #lightblue
participant "NukeBuild" as nuke #lightcoral
participant "ExecutionEngine" as engine #lightcoral
participant "Install Target" as target #orange
participant "PackageManager" as pm1 #yellow

participant "Program" as prog2 #lightgreen
participant "Parser" as parser #lightgreen
participant "InvocationContext" as context #lightgreen
participant "PackageHandlers" as handler #lightgreen
participant "IPackageManagerService" as svc #lightgreen
participant "PackageManagerService" as impl #lightgreen

== Current Nuke.Build Flow ==

user -> prog1 : vc-build Install -module Core
activate prog1

prog1 -> nuke : Execute<Build>(x => x.Install)
activate nuke

nuke -> engine : ExecuteTarget(Install)
activate engine

engine -> target : Executes(() => { ... })
activate target

note over target
  Complex business logic
  embedded directly in target:
  
  var packageManifest = await OpenOrCreateManifest(...);
  var githubModuleSources = PackageManager.GetGithubModuleManifests(...);
  var modules = PackageManager.GetGithubModules(...);
  var localModuleCatalog = LocalModuleCatalog.GetCatalog(...);
  // 50+ lines of mixed logic...
end note

target -> pm1 : GetGithubModules(packageManifest)
activate pm1
pm1 --> target : List<ModuleItem>
deactivate pm1

target -> pm1 : ToFile(packageManifest, path)
activate pm1
pm1 --> target : void
deactivate pm1

target --> engine : execution result
deactivate target

engine --> nuke : execution result
deactivate engine

nuke --> prog1 : exit code
deactivate nuke

prog1 --> user : exit code
deactivate prog1

== Future System.CommandLine Flow ==

user -> prog2 : vc-build package install --modules Core
activate prog2

prog2 -> parser : InvokeAsync(args)
activate parser

parser -> context : Create InvocationContext
activate context

context -> handler : HandleInstallAsync(context)
activate handler

note over handler
  Clean handler with DI:
  
  var options = ParseOptions(context);
  var packageService = serviceProvider
    .GetRequiredService<IPackageManagerService>();
  
  try {
    await packageService.InstallAsync(options);
    return 0;
  } catch (Exception ex) {
    logger.LogError(ex, "Install failed");
    return 1;
  }
end note

handler -> svc : GetRequiredService<IPackageManagerService>()
activate svc

handler -> svc : InstallAsync(options)

svc -> impl : InstallAsync(options)
activate impl

note over impl
  Service implementation:
  
  _telemetry.TrackEvent("Package.Install", options);
  
  var manifest = await _packageManager.OpenOrCreateManifest(...);
  var catalog = await _moduleCatalog.GetCatalog(...);
  
  await ProcessModules(options, manifest, catalog);
  
await _packageManager.SaveManifest(manifest);
end note

impl -> pm1 : OpenOrCreateManifest(path)
activate pm1
pm1 --> impl : ManifestBase
deactivate pm1

impl -> pm1 : SaveManifest(manifest)
activate pm1
pm1 --> impl : void
deactivate pm1

impl --> svc : void
deactivate impl

svc --> handler : void
deactivate svc

handler --> context : 0 (success)
deactivate handler

context --> parser : 0
deactivate context

parser --> prog2 : 0
deactivate parser

prog2 --> user : 0
deactivate prog2

== System.CommandLine Benefits ==

note over parser, impl
  <b><color:green>System.CommandLine Advantages:</color></b>
  • Microsoft's official CLI framework
  • Rich parsing and validation
  • Built-in help and tab completion
  • Excellent error messages
  • Integration with Microsoft.Extensions.DI
  • Standardized patterns
  • Active development and support
end note

note over handler, impl
  <b><color:blue>Architecture Benefits:</color></b>
  • Clean separation via handlers
  • Dependency injection throughout
• Testable components
  • Standard Microsoft patterns
  • InvocationContext provides rich context
  • Easy parameter binding and validation
end note

@enduml
